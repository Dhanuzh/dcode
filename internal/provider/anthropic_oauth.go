package provider

import (
	"bytes"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/Dhanuzh/dcode/internal/config"
)

const (
	anthropicOAuthClientID    = "9d1c250a-e61b-44d9-88ed-5944d1962f5e"
	anthropicOAuthRedirectURI = "https://console.anthropic.com/oauth/code/callback"
	anthropicOAuthTokenURL    = "https://console.anthropic.com/v1/oauth/token"
	anthropicOAuthAuthURL     = "https://claude.ai/oauth/authorize"
	anthropicOAuthScope       = "org:create_api_key user:profile user:inference"
)

// AnthropicPKCE holds the generated PKCE values for one OAuth flow
type AnthropicPKCE struct {
	Verifier  string // random secret; also used as state
	Challenge string // base64url(SHA256(Verifier))
}

// generatePKCE generates a cryptographically random PKCE verifier and its S256 challenge.
// The verifier is also used as the OAuth state parameter (matching opencode's behaviour).
func generatePKCE() (*AnthropicPKCE, error) {
	// 32 random bytes â†’ 43-char base64url string (no padding)
	raw := make([]byte, 32)
	if _, err := rand.Read(raw); err != nil {
		return nil, fmt.Errorf("failed to generate random bytes: %w", err)
	}
	verifier := base64.RawURLEncoding.EncodeToString(raw)

	// challenge = base64url(SHA256(verifier)), no padding
	sum := sha256.Sum256([]byte(verifier))
	challenge := base64.RawURLEncoding.EncodeToString(sum[:])

	return &AnthropicPKCE{
		Verifier:  verifier,
		Challenge: challenge,
	}, nil
}

// AnthropicOAuthAuthorizeResult holds the URL to open and the verifier to remember
type AnthropicOAuthAuthorizeResult struct {
	URL      string
	Verifier string
}

// AnthropicOAuthAuthorize builds a real PKCE-based OAuth URL for Claude Pro/Max.
// The caller must open the returned URL in a browser, then collect the code+state
// string pasted back by the user and pass it to AnthropicOAuthExchange.
func AnthropicOAuthAuthorize() (*AnthropicOAuthAuthorizeResult, error) {
	pkce, err := generatePKCE()
	if err != nil {
		return nil, err
	}

	params := url.Values{}
	params.Set("code", "true")
	params.Set("client_id", anthropicOAuthClientID)
	params.Set("response_type", "code")
	params.Set("redirect_uri", anthropicOAuthRedirectURI)
	params.Set("scope", anthropicOAuthScope)
	params.Set("code_challenge", pkce.Challenge)
	params.Set("code_challenge_method", "S256")
	params.Set("state", pkce.Verifier) // verifier doubles as state (opencode behaviour)

	authURL := anthropicOAuthAuthURL + "?" + params.Encode()
	return &AnthropicOAuthAuthorizeResult{
		URL:      authURL,
		Verifier: pkce.Verifier,
	}, nil
}

// AnthropicOAuthExchange exchanges the authorization code for access/refresh tokens.
// codeAndState is the raw string pasted by the user: "<code>#<state>"
// verifier is the PKCE code_verifier generated by AnthropicOAuthAuthorize.
func AnthropicOAuthExchange(codeAndState, verifier string) (*config.OAuthToken, error) {
	// Split on "#"
	parts := strings.SplitN(codeAndState, "#", 2)
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid authorization code format: expected \"<code>#<state>\"")
	}
	code := strings.TrimSpace(parts[0])
	state := strings.TrimSpace(parts[1])

	if code == "" || state == "" {
		return nil, fmt.Errorf("authorization code or state is empty")
	}

	body := map[string]string{
		"code":          code,
		"state":         state,
		"grant_type":    "authorization_code",
		"client_id":     anthropicOAuthClientID,
		"redirect_uri":  anthropicOAuthRedirectURI,
		"code_verifier": verifier,
	}

	return doTokenRequest(body)
}

// AnthropicOAuthRefresh uses a refresh token to obtain a new access token.
func AnthropicOAuthRefresh(refreshToken string) (*config.OAuthToken, error) {
	body := map[string]string{
		"grant_type":    "refresh_token",
		"refresh_token": refreshToken,
		"client_id":     anthropicOAuthClientID,
	}
	return doTokenRequest(body)
}

// doTokenRequest POSTs to the Anthropic token endpoint and returns a parsed OAuthToken.
func doTokenRequest(payload map[string]string) (*config.OAuthToken, error) {
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal token request: %w", err)
	}

	client := &http.Client{Timeout: 20 * time.Second}
	req, err := http.NewRequest("POST", anthropicOAuthTokenURL, bytes.NewReader(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create token request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "dcode/2.0")

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("token request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read token response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		// Try to extract error message
		var errResp struct {
			Error            string `json:"error"`
			ErrorDescription string `json:"error_description"`
		}
		msg := string(respBody)
		if json.Unmarshal(respBody, &errResp) == nil && errResp.ErrorDescription != "" {
			msg = errResp.ErrorDescription
		} else if json.Unmarshal(respBody, &errResp) == nil && errResp.Error != "" {
			msg = errResp.Error
		}
		return nil, fmt.Errorf("token exchange failed (HTTP %d): %s", resp.StatusCode, msg)
	}

	var tokenResp struct {
		AccessToken  string `json:"access_token"`
		RefreshToken string `json:"refresh_token"`
		ExpiresIn    int    `json:"expires_in"` // seconds
		TokenType    string `json:"token_type"`
	}
	if err := json.Unmarshal(respBody, &tokenResp); err != nil {
		return nil, fmt.Errorf("failed to parse token response: %w", err)
	}
	if tokenResp.AccessToken == "" {
		return nil, fmt.Errorf("token response contained no access_token")
	}

	expiresAt := int64(0)
	if tokenResp.ExpiresIn > 0 {
		expiresAt = time.Now().Unix() + int64(tokenResp.ExpiresIn)
	}

	return &config.OAuthToken{
		AccessToken:  tokenResp.AccessToken,
		RefreshToken: tokenResp.RefreshToken,
		ExpiresAt:    expiresAt,
		TokenType:    tokenResp.TokenType,
	}, nil
}

// SaveAnthropicOAuthToken persists the OAuth token for the "anthropic" provider.
func SaveAnthropicOAuthToken(token *config.OAuthToken) error {
	creds, err := config.LoadCredentials()
	if err != nil || creds == nil {
		creds = &config.Credentials{}
	}
	if creds.OAuthTokens == nil {
		creds.OAuthTokens = make(map[string]*config.OAuthToken)
	}
	creds.OAuthTokens["anthropic"] = token
	return config.SaveCredentials(creds)
}

// ClearAnthropicOAuthToken removes the stored Anthropic OAuth token.
func ClearAnthropicOAuthToken() error {
	creds, err := config.LoadCredentials()
	if err != nil || creds == nil {
		return nil
	}
	if creds.OAuthTokens != nil {
		delete(creds.OAuthTokens, "anthropic")
	}
	return config.SaveCredentials(creds)
}

// GetAnthropicOAuthToken loads the stored Anthropic OAuth token.
// If the token is expired and a refresh token is available, it is refreshed automatically
// and the new token is saved before being returned.
// Returns (nil, nil) if no token is stored.
func GetAnthropicOAuthToken() (*config.OAuthToken, error) {
	creds, err := config.LoadCredentials()
	if err != nil || creds == nil {
		return nil, nil
	}
	if creds.OAuthTokens == nil {
		return nil, nil
	}
	token, ok := creds.OAuthTokens["anthropic"]
	if !ok || token == nil {
		return nil, nil
	}

	// Auto-refresh if expired
	if token.IsExpired() && token.RefreshToken != "" {
		newToken, err := AnthropicOAuthRefresh(token.RefreshToken)
		if err != nil {
			return nil, fmt.Errorf("failed to refresh Anthropic OAuth token: %w", err)
		}
		// Preserve refresh token if the new response didn't include one
		if newToken.RefreshToken == "" {
			newToken.RefreshToken = token.RefreshToken
		}
		if err := SaveAnthropicOAuthToken(newToken); err != nil {
			return nil, fmt.Errorf("failed to save refreshed token: %w", err)
		}
		return newToken, nil
	}

	return token, nil
}
